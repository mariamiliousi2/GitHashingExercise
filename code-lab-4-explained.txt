Για κάθε αρχείο από το /tmp/lab04/examples{1-5}.c
μπορείτε να το μεταγλωττίσετε χρησιμοποιώντας τον GCC compiler
και να το εκτελέσετε στο τερματικό.
Η εντολή που χρησιμοποιείται για τη μεταγλώττιση είναι η εξής:
gcc -o exampleX exampleX.c
και η εντολή ./exampleX εκτελεί το πρόγραμμα.

-------------------------------------------------------------------------

example1
Parent Process: PID = 3778616, Created Child PID = 3778617
Child Process: PID = 3778617, Parent PID = 3778616
total 48
-rwxrwxr-x 1 miliousi miliousi 17048 Jan 19 15:57 example1
-rw-rw-r-- 1 miliousi miliousi   855 Jan 16 13:27 example1.c
-rw-rw-r-- 1 miliousi miliousi   347 Jan 16 13:27 example2.c
-rw-rw-r-- 1 miliousi miliousi   643 Jan 16 13:27 example3.c
-rw-rw-r-- 1 miliousi miliousi   670 Jan 16 13:27 example4.c
-rw-rw-r-- 1 miliousi miliousi  1622 Jan 16 13:28 example5.c
-rw-rw-r-- 1 miliousi miliousi    45 Jan 16 13:36 lab04.tar.gz
-rw-rw-r-- 1 miliousi miliousi   564 Jan 16 13:28 Makefile
Parent Process: Child has terminated.

Αυτός ο κώδικας γράφει ένα πρόγραμμα σε C
που δημιουργεί μια νέα διεργασία χρησιμοποιώντας την fork(),
εκτελεί μία άλλη εντολή μέσω της execlp(),
και το πρόγραμμα περιλαμβάνει χειρισμό
για την αναμονή της τερματισμένης διεργασίας από τον γονέα.
Η συνάρτηση fork() δημιουργεί μια νέα διεργασία.
Ο νέος διαδικαστικός χώρος αντιπροσωπεύει το "παιδί" του τρέχοντος προγράμματος
Που είναι ο "γονέας"
Αν fork() αποτύχει(δηλαδή επιστρέψει -1), το πρόγραμμα εκτυπώνει ένα μήνυμα σφάλματος 
και τερματίζει με exit(EXIT_FAILURE).
Η execlp() είναι μια λειτουργία που αντικαθιστά το τρέχον εκτελέσιμο πρόγραμμα με το νέο.
Αν η execlp() αποτύχει (π.χ., αν δεν μπορεί να βρει το ls),
τότε εκτυπώνεται το μήνυμα σφάλματος και η διεργασία τερματίζεται με exit(EXIT_FAILURE).

-----------------------------------------------------------------------

example2
Current Process ID (PID): 3787440
Parent Process ID (PPID): 3787273
Eμφανίζεται το PID της τρέχουσας διεργασίας και το PPID της parent διεργασίας

Ο κώδικας χρησιμοποιεί τη getpid() για να επιστρέψει το PID της τρέχουσας
διεργασίας και τη getppid() για να επιστρέψει το PID της parent διεργασίας 

---------------------------------------------------------------------

example3

Το πρόγραμμα εκτυπωνει το παρακάτω μήνυμα κάθε 2 δευτερόλεπτα και περιμένει το σήμα SIGINT
με Ctrl + C
Process ID: 3787499
Press Ctrl+C to trigger SIGINT.
Running... Press Ctrl+C to exit.
Running... Press Ctrl+C to exit.
^C
Caught signal 2 (SIGINT). Exiting gracefully...

Ο κώδικας ορίζει μια συνάρτηση sigint_handler
που εκτελείται όταν λαμβάνεται το σήμα SIGINT.
Χρησιμοποιεί τη signal() για την εγγραφή του handler
στη θέση του προκαθορισμένου χειριστή για το SIGINT.
Το πρόγραμμα εκτελεί έναν ατέρμονα βρόχο που εκτυπώνει μηνύματα κάθε 2 δευτερόλεπτα,
περιμένοντας την είσοδο χρήστη.
Όταν πατηθεί Ctrl+C, καλείται η sigint_handler, η οποία τερματίζει το πρόγραμμα.

-------------------------------------------------------------------

example4
Process ID: 378749

Ο κώδικας ορίζει μια συνάρτηση sigint_handler,
που ενεργοποιείται όταν ληφθεί το σήμα SIGINT.
Tότε αντί να τερματίζει το πρόγραμμα, εμφανίζει μήνυμα ότι αγνοεί το σήμα.
Η signal() εγγράφει τη sigint_handler ως χειριστή για το SIGINT.
Ο βρόχος while(1) εκτυπώνει μηνύματα και συνεχίζει την εκτέλεση
χωρίς να τερματίζει ποτέ.

------------------------------------------------------------------

example5
Child process ID: 3788137. Waiting for SIGUSR1...
Parent process ID: 3788136. Child PID: 3788137
Parent sending SIGUSR1 to child.
Child received SIGUSR1 (signal 10).
Parent sending SIGTERM to child.
Child process terminated.

Ο κώδικας δημιουργεί μία νέα διεργασία με τη fork().
Η child διεργασία εγγράφει έναν χειριστή για το σήμα SIGUSR1
και εισέρχεται σε ατέρμονα βρόχο με pause() για να περιμένει σήματα.
Η parent διεργασία στέλνει το σήμα SIGUSR1
για να ενεργοποιήσει τον handler της child
και στη συνέχεια στέλνει SIGTERM για να τερματίσει τη διεργασία.
Η wait() διασφαλίζει ότι η parent περιμένει
τον τερματισμό της child πριν ολοκληρωθεί.

